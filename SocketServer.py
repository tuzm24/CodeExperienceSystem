import socketserverimport threadingfrom Server import taskGroupfrom debug.logging import LoggingHelper as lhfrom config import Configimport osimport queueimport timeimport math#HOST = '223.195.38.111'HOST = '192.168.0.5'#HOST = '223.195.38.107'# HOST = 'localhost'PORT = 3100BUFSIZE = 1024ADDR = (HOST, PORT)lock = threading.Lock()tasklock = threading.Lock()class UserManager:    users = {}  # 사용자의 등록 정보를 담을 사전 {사용자 이름:(소켓,주소),...}    runningcores = {}    totalcores = {}    seqs = {}    isInitTG = {}    config = Config("config.yml")    logger = lh.get_instace(config).logger    taskG = {}    userlock = {}    runningflag = False    #def __init__(self):    def AssignNewTask(self, task, client):        # self.logger.info('Task assign to [%s] - [%s]' %(client, task.name))        msg = 'AssTask\t'+task.TaskToTaskMessege()        self.sendMessageToUnique(msg, client)        self.runningcores[client] +=1        return    def getNextClient(self):        minpercent = 1000        nextclient = ''        for username in self.users.keys():            percent = (int)(((self.runningcores[username]+1) * 100.0)/self.totalcores[username]+0.5)            if percent<minpercent:                nextclient = username                minpercent = percent        # self.logger.info("%s : %s%% cores" % (nextclient, minpercent))        return nextclient, minpercent    def getTotalCores(self):        tmp = 0        for core in self.totalcores.values():            tmp += core        return tmp    def isAllClientReady(self, target):        for isinit in self.isInitTG.values():            if isinit < target.gid:                return False        return True    def getRunningCores(self):        tmp = 0        for core in self.runningcores.values():            tmp +=core        return tmp    def remainCoreNumber(self):        return self.getTotalCores() - self.getRunningCores()    def PrintAllUser(self):        print('+++ 연결 컴퓨터 수 [%d] +++ 전체 쓰레드 [%d]중 [%d]개 사용가능' % (len(self.users), self.getTotalCores(), self.getTotalCores()- self.getRunningCores()))        print('--- 연결 컴퓨터 목록')        for username in self.users.keys():            print('[%s] : [%d]쓰레드 중 [%d]개 사용가능' %(username, self.totalcores[username], self.runningcores[username]))        return    def addUser(self, userinfo, conn, addr):  # 사용자 ID를 self.users에 추가하는 함수        tasklock.acquire()        username = userinfo[0]        usercores = (int)(userinfo[1])-4        userseqs_num = (int)(userinfo[2])        userseqs = []        for i in range(3,len(userinfo)):            userseqs.append(userinfo[i])        if len(userseqs)!=userseqs_num:            self.logger.warning(" No match seqs Number!")        if username in self.users:  # 이미 등록된 사용자라면            conn.send('이미 등록된 사용자입니다.\n'.encode())            return None        # 새로운 사용자를 등록함        lock.acquire()  # 스레드 동기화를 막기위한 락        self.users[username] = (conn, addr)        self.seqs[username] = userseqs        self.isInitTG[username] = 0        self.userlock[username] = threading.Lock()        lock.release()  # 업데이트 후 락 해제        self.logger.info('[%s] 컴퓨터가 연결되었습니다' %username)        if self.runningflag:            for tg in self.taskG.values():                self.sendMessageToUnique('initTaskGroup' + str(tg.gid), username)                while self.isInitTG[username] != tg.gid:                    pass        self.runningcores[username] = 0        self.totalcores[username] = usercores        self.logger.info('+++ 연결 컴퓨터 수 [%d] +++ 가용 Cpu 개수 [%d]' % (len(self.users), self.getTotalCores()))        tasklock.release()        return username    def removeUser(self, username):  # 사용자를 제거하는 함수        if username not in self.users:            self.logger.error('Not exist user %s in user lists' %(username))            return        lock.acquire()        del self.users[username]        del self.totalcores[username]        del self.seqs[username]        del self.runningcores[username]        del self.isInitTG[username]        del self.userlock[username]        lock.release()        self.logger.info('[%s] 컴퓨터 연결이 끊어졌습니다.' % username)        self.logger.info('--- 연결 컴퓨터 수 [%d] --- 총 Cpu 개수 [%d]' % (len(self.users), self.getTotalCores()))        #self.sendMessageToAll('[%s]님이 퇴장했습니다.' % username)        #print('--- 연결 컴퓨터 수 [%d] --- 가용 Cpu 개수 [%d]' % (len(self.users), self.totalcore))    def recvFile(self, username, filepath):        (conn, addr) = self.users[username]        filedata = conn.recv(2048).decode().strip().split('\t')        # print(filedata)        filename = filedata[0]        filesize = filedata[1]        conn.send(filedata[0].encode())        data = conn.recv(2048)        data_transferred = 0        filesize = (int)(filesize)        filepath = filepath+ '/' +filename        # print(filepath, filesize)        with open(filepath, 'wb') as f:            try:                while data:                    f.write(data)                    data_transferred +=len(data)                    if data_transferred==filesize:                        break                    data = conn.recv(2048)            except Exception as e:                self.logger.warning(e)        self.logger.debug("(Filename : %s), (Filesize :  %s), (File Transferred : %s)" %(filename, filesize, data_transferred))        conn.send(str(data_transferred).encode())        return filename    def recvTask(self, username):        finish_tasks = taskGroup.FinishedTask        running_tasks = taskGroup.RunningTask        (conn, addr) = self.users[username]        conn.send(' '.encode())        msg = conn.recv(2048).decode().strip()        msg = msg.split('\t')        gid = msg[0]        taskid = int(msg[1])        # filepath = None        # cur_tg = None        cur_tg = self.taskG[gid]        # for tg in self.taskG:        #     if str(tg.gid)==gid:        #         filepath = tg.binpath        #         cur_tg = tg        filepath = cur_tg.binpath        # if cur_tg == None:        #     self.logger.error('Can not Found TaskGroup')        #     return False        conn.send('Ready'.encode()) # Unlock        for i in range(3):            self.recvFile(username=username, filepath = filepath)        cur_task = running_tasks[taskid]        del running_tasks[taskid]        if taskid in finish_tasks:            self.logger.warning('Already Finished Task!')            return True        finish_tasks[taskid] = cur_task        cur_tg.task_finish_num +=1        self.logger.info('Recv finished file : %s' %cur_task.name)        if  cur_tg.ParseResult():            self.logger.info("Taskgroup name '%s' is Finished" %(cur_tg.gname))        # if cur_tg.isAllTaskFinish():        self.runningcores[username] -= 1        return True    def messageHandler(self, username, msg):  # 전송한 msg를 처리하는 부분        msg = msg.split('\t')        # self.logger.info('%s : %s' %(username, msg[0]))        if 'initTaskGroup' in msg[0] : #서버가 전송한 요청에 Rcv            self.initGroupToUnique(username, self.taskG[msg[0].split('initTaskGroup')[1]])            self.userlock[username].release()            return        # if msg[0] == 'FinishTask':            # (conn, addr) = self.users[username]            # conn.send('Ready'.encode()) # Unlock            # self.recvTask(username=username)            # self.sendMessageToUnique('Flush', username)        if msg[0] == 'Flush':            flushnum = int(msg[1])            if flushnum != 0:                for i in range(flushnum): # Flush Number                    self.recvTask(username=username)            self.userlock[username].release()        if msg[0] == 'AssTask':            self.userlock[username].release()        # if msg[0] == 'ReadyToRcvTask': #서버가 전송한 요청에 Rcv        #     pass    def sendMessageToAll(self, msg):        for userlock in self.userlock.values():            userlock.acquire()        for conn, addr in self.users.values():            conn.send(msg.encode())    def sendMessageToUnique(self, msg, username):        self.userlock[username].acquire()        (conn, addr) = self.users[username]        conn.send(msg.encode())    def sendFileToUnique(self, filepath, username):        data_transfered = 0        filesize = os.path.getsize(filepath)        filename = os.path.basename(filepath)        (conn, addr) = self.users[username]        conn.send((filename+'\t'+str(filesize)).encode())        conn.recv(2048) # recv : filename        with open(filepath, 'rb') as f:            try:                data = f.read(2048)                while data:                    data_transfered += conn.send(data)                    data = f.read(2048)            except Exception as e:                self.logger.info(e)        recv_size = int(conn.recv(2048))        if data_transfered==recv_size:            self.logger.info("      Send Success (%s : %s)" %(filepath, data_transfered))        else:            self.logger.error("     Send Fail (%s : %s)" %(filepath, data_transfered))        return    def initGroupToUnique(self, username, task):        (conn, addr) = self.users[username]        # task = self.taskG[taskGidx]        msg = str(task.gid) + '\t' + task.gname + '\t' + str(len(task.cfglist))        conn.send(msg.encode())        conn.recv(2048) # recv : recv        self.logger.info("Send TaskGroup Info to (%s)" %(username))        self.sendFileToUnique(task.encPath, username)        self.sendFileToUnique(task.decPath, username)        for cfgpath in task.cfglist:            self.sendFileToUnique(cfgpath, username)        conn.send('Finish'.encode())        conn.recv(2048)        self.logger.info("Sending TaskGroup Info is Finished (%s - gid(%s))" %(username, task.gid))        self.isInitTG[username] = task.gid        returnclass MyTcpHandler(socketserver.BaseRequestHandler):    userman = UserManager() #usermanger 클래스 객체    def handle(self):  # 클라이언트가 접속시 클라이언트 주소 출력        self.userman.logger.info('[%s] 연결됨' % self.client_address[0])        # try:        username = self.registerUsername() #registerUsername -> addUser        # while True:        #     pass        msg = self.request.recv(1024)        while msg:            #self.userman.logger.info("{} : {}".format(username, msg.decode()))            if self.userman.messageHandler(username, msg.decode()) == -1:                self.request.close()                break            msg = self.request.recv(1024)        # except Exception as e:        #     self.userman.logger.error(e)        #print('[%s] 접속종료' % self.client_address[0])        self.userman.removeUser(username)    def registerUsername(self):        while True:            #self.request.send('로그인ID:'.encode())            #self.request.recv(BUFSIZE)            userinfo = self.request.recv(1024*16) # Name, CpuCoreNuber, Sequences            userinfo = userinfo.decode().strip()            userinfo = userinfo.split('\t')            if self.userman.addUser(userinfo, self.request, self.client_address):                return userinfo[0]class CodecServer(socketserver.ThreadingMixIn, socketserver.TCPServer):    passdef runServer():    userman = UserManager()    print('===================================')    print('Video Coding Software Distributed Computing System')    print('Made by Yangwoo Kim')    print('version v1.0')    print('===================================')    print('- 주의사항')    print('-- 프로그램을 종료시키면 모든 실험이 중단됩니다.')    print('-- 종료하려면 ctrl + c')    print('===================================')    userman.logger.warning("Program Start")    try:        server = CodecServer((HOST, PORT), MyTcpHandler)        server.serve_forever()    except KeyboardInterrupt:        userman.logger.warning('Server has been shut down.')def getQueuelist(q):    l = list(q.queue)    prioQ = queue.PriorityQueue()    idx = 0    for i in l:        prioQ.put((i[0], i[1]))    while prioQ.qsize()!=0:        tmptask = prioQ.get()[1]        print("Print Remain Task")        print('Priority %d : %s - %s' %(idx, tmptask.gname, tmptask.name))        idx +=1def runSendTask(logger):    tasks = taskGroup.tasks    # finish_tasks = taskGroup.FinishedTask    running_tasks = taskGroup.RunningTask    userman = UserManager()    while True:        while tasks.qsize()!=0 and userman.remainCoreNumber()!=0:            tasklock.acquire()            target_client_name, cpuPercent = userman.getNextClient()            cur_task = tasks.get()[1]            running_tasks[cur_task.taskid] = cur_task            userman.AssignNewTask(cur_task, target_client_name)            logger.info("Task Assign - [client : (%s : %s%%)]  [task : (%s)]" %(target_client_name, cpuPercent, cur_task.name))            tasklock.release()        if tasks.qsize()==0:            logger.info("Empty Task Queue")            userman.runningflag = False            break    returndef CheckFlush(logger):    tasks = taskGroup.tasks    # finish_tasks = taskGroup.FinishedTask    running_tasks = taskGroup.RunningTask    userman = UserManager()    while len(running_tasks)!=0 or tasks.qsize()!=0:        time.sleep(5)        userman.sendMessageToAll('Flush')    logger.info('Flush Thread is exited')def runServerAdmin():    print("Server Administrator Run")    userman = UserManager()    while True:        msg = input()        # try:        if msg.split(' ')[0]=='run':            # try:            target = taskGroup(msg.split(' ')[1])            userman.logger.info('Taskgroup(%s) Init' %(target.gname))            userman.taskG[str(target.gid)] = target            userman.sendMessageToAll('initTaskGroup' + str(target.gid))            while not userman.isAllClientReady(target):                pass            if userman.runningflag==False:                userman.runningflag = True                t = threading.Thread(target = runSendTask, args = (userman.logger,))                t.daemon = True                t.start()                t2 = threading.Thread(target=CheckFlush, args = (userman.logger,))                t2.daemon = True                t2.start()            # except Exception as e:            #     userman.logger.info(e)        elif msg=='print task':            getQueuelist(taskGroup.tasks)        elif msg=='print cores':            print(userman.getNextClient())        elif msg.split('\t')[0]=='eval':            exec(msg.split('\t')[1])        # except Exception as e:        #     userman.logger.info(e)if __name__=='__main__':    t = threading.Thread(target = runServer)    #runtask = threading.Thread(target=runSendTask)    t.start()    #runtask.start()    runServerAdmin()